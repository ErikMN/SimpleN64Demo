#include <ultra64.h>
#include <PR/ramrom.h> // needed for argument passing into the app
#include <assert.h>

#include "static.h"
#include "controller.h"

/*
 * Symbol genererated by "makerom" to indicate the end of the code segment
 * in virtual (and physical) memory
 */
extern char _codeSegmentEnd[];

/*
 * Symbols generated by "makerom" to tell us where the static segment is
 * in ROM.
 */
extern char _staticSegmentRomStart[], _staticSegmentRomEnd[];

/*
 * Stacks for the threads as well as message queues for synchronization
 * This stack is ridiculously large, and could also be reclaimed once
 * the main thread is started.
 */
u64 bootStack[STACKSIZE / sizeof(u64)];

static void idle(void *);
static void mainproc(void *);

static OSThread idleThread;
static u64 idleThreadStack[STACKSIZE / sizeof(u64)];

static OSThread mainThread;
static u64 mainThreadStack[STACKSIZE / sizeof(u64)];

/* this number (the depth of the message queue) needs to be equal
 * to the maximum number of possible overlapping PI requests.
 * For this app, 1 or 2 is probably plenty, other apps might
 * require a lot more.
 */
#define NUM_PI_MSGS 8

static OSMesg PiMessages[NUM_PI_MSGS];
static OSMesgQueue PiMessageQ;

OSMesgQueue dmaMessageQ, rdpMessageQ, retraceMessageQ;
OSMesg dmaMessageBuf, rdpMessageBuf, retraceMessageBuf;
OSIoMesg dmaIOMessageBuf; // see man page to understand this

Dynamic dynamic; // Dynamic data

// Task descriptor:
OSTask tlist = {
  M_GFXTASK,                       // task type
  OS_TASK_DP_WAIT,                 // task flags
  NULL,                            // boot ucode pointer (fill in later)
  0,                               // boot ucode size (fill in later)
  NULL,                            // task ucode pointer (fill in later)
  SP_UCODE_SIZE,                   // task ucode size
  NULL,                            // task ucode data pointer (fill in later)
  SP_UCODE_DATA_SIZE,              // task ucode data size
  &dram_stack[0],                  // task dram stack pointer
  SP_DRAM_STACK_SIZE8,             // task dram stack size
  &rdp_output[0],                  // task fifo buffer start ptr
  &rdp_output[0] + RDP_OUTPUT_LEN, // task fifo buffer end ptr
  NULL,                            // task data pointer (fill in later)
  0,                               // task data size (fill in later)
  NULL,                            // task yield buffer ptr (not used here)
  0                                // task yield buffer size (not used here)
};

Gfx *glistp; // global for test case procs

// global variables
static float theta = 0.0;
static int rdp_flag = 0;   // 0:xbus , 1:fifo
static int do_texture = 0; // use texture
static int draw_buffer = 0;

OSPiHandle *handler;

void
boot(void)
{
  // notice that you can't call osSyncPrintf() until you set up an idle thread
  osInitialize();
  handler = osCartRomInit();
  osCreateThread(&idleThread, 1, idle, (void *)0, idleThreadStack + STACKSIZE / sizeof(u64), 10);
  osStartThread(&idleThread);
  // never reached
}

static void
idle(void *arg)
{
  // Initialize video
  osCreateViManager(OS_PRIORITY_VIMGR);
  osViSetMode(&osViModeTable[OS_VI_NTSC_LAN1]);

  // Start PI Mgr for access to cartridge
  osCreatePiManager((OSPri)OS_PRIORITY_PIMGR, &PiMessageQ, PiMessages, NUM_PI_MSGS);

  // Create main thread
  osCreateThread(&mainThread, 3, mainproc, NULL, mainThreadStack + STACKSIZE / sizeof(u64), 10);
  osStartThread(&mainThread);

  osSetThreadPri(0, 0); // Become the idle thread
  for (;;)
    ;
}

// This is the main routine of the app.
static void
mainproc(void *arg)
{
  OSTask *tlistp;
  Dynamic *dynamicp;
  OSContPad **pad;
  char *staticSegment;
  int toggle = 0;

  osSyncPrintf("Hello World!\n");

  // Setup the message queues
  osCreateMesgQueue(&dmaMessageQ, &dmaMessageBuf, 1);
  osCreateMesgQueue(&rdpMessageQ, &rdpMessageBuf, 1);
  osSetEventMesg(OS_EVENT_DP, &rdpMessageQ, NULL);

  osCreateMesgQueue(&retraceMessageQ, &retraceMessageBuf, 1);
  osViSetEvent(&retraceMessageQ, NULL, 1);

  // Stick the static segment right after the code/data segment
  staticSegment = _codeSegmentEnd;
  dmaIOMessageBuf.hdr.pri = OS_MESG_PRI_NORMAL;
  dmaIOMessageBuf.hdr.retQueue = &dmaMessageQ;
  dmaIOMessageBuf.dramAddr = staticSegment;
  dmaIOMessageBuf.devAddr = (u32)_staticSegmentRomStart;
  dmaIOMessageBuf.size = (u32)_staticSegmentRomEnd - (u32)_staticSegmentRomStart;
  osEPiStartDma(handler, &dmaIOMessageBuf, OS_READ);

  // Wait for DMA to finish
  (void)osRecvMesg(&dmaMessageQ, NULL, OS_MESG_BLOCK);

  // initialize the controllers:
  initControllers(MAXCONTROLLERS);

  // Main game loop
  while (1) {

    pad = ReadController(0);

    // pointers to build the display list.
    tlistp = &tlist;
    dynamicp = &dynamic;

    guOrtho(&dynamicp->projection,
            -(float)SCREEN_WD / 2.0F,
            (float)SCREEN_WD / 2.0F,
            -(float)SCREEN_HT / 2.0F,
            (float)SCREEN_HT / 2.0F,
            -999.0F,
            999.0F,
            1.0F);

    // Make it move:
    // guRotate(&dynamicp->modeling, theta, 0.0F, 0.0F, 1.0F); // rotate z

    guRotate(&dynamicp->modeling, theta, 0, 1, 1); // a, x, y, z
    // guTranslate(&dynamicp->modeling, theta, theta, 0.0f); // move the tri
    // guScale(&dynamicp->modeling, theta, theta, 0.0f);

    glistp = dynamicp->glist;

    // Tell RCP where each segment is
    gSPSegment(glistp++, 0, 0x0); // Physical address segment
    gSPSegment(glistp++, STATIC_SEGMENT, OS_K0_TO_PHYSICAL(staticSegment));
    gSPSegment(glistp++, CFB_SEGMENT, OS_K0_TO_PHYSICAL(cfb[draw_buffer]));

    gSPDisplayList(glistp++, rdpinit_dl); // Initialize RDP state.
    gSPDisplayList(glistp++, rspinit_dl); // Initialize RSP state.
    gSPDisplayList(glistp++, clearzbuffer_dl);
    gSPDisplayList(glistp++, clearcfb_dl); // Clear color framebuffer.

    // simple triangle or cube:
    if (do_texture) {
      gSPDisplayList(glistp++, textri_dl); // use texture
    } else {
      gSPDisplayList(glistp++, shade_cube_dl);
      // gSPDisplayList(glistp++, shadetri_simple_dl);
    }

    gDPFullSync(glistp++);
    gSPEndDisplayList(glistp++);

    // Build graphics task:
    tlistp->t.ucode_boot = (u64 *)rspbootTextStart;
    tlistp->t.ucode_boot_size = (u32)rspbootTextEnd - (u32)rspbootTextStart;

    // choose which ucode to run:
    if (rdp_flag) {
      // RSP output over FIFO to RDP
      tlistp->t.ucode = (u64 *)gspF3DEX2_fifoTextStart;
      tlistp->t.ucode_data = (u64 *)gspF3DEX2_fifoDataStart;
    } else {
      // RSP output over XBUS to RDP:
      tlistp->t.ucode = (u64 *)gspF3DEX2_xbusTextStart;
      tlistp->t.ucode_data = (u64 *)gspF3DEX2_xbusDataStart;
    }

    // initial display list:
    tlistp->t.data_ptr = (u64 *)dynamicp->glist;
    tlistp->t.data_size = (u32)((glistp - dynamicp->glist) * sizeof(Gfx));

    // Write back dirty cache lines that need to be read by the RCP.
    osWritebackDCache(&dynamic, sizeof(dynamic));
    osSpTaskStart(tlistp);                               // start up the RSP task
    (void)osRecvMesg(&rdpMessageQ, NULL, OS_MESG_BLOCK); // wait for RDP completion
    osViSwapBuffer(cfb[draw_buffer]);                    // setup to swap buffers

    // Make sure there isn't an old retrace in queue (assumes queue has a depth
    // of 1)
    if (MQ_IS_FULL(&retraceMessageQ)) {
      (void)osRecvMesg(&retraceMessageQ, NULL, OS_MESG_BLOCK);
    }

    // Wait for Vertical retrace to finish swap buffers
    (void)osRecvMesg(&retraceMessageQ, NULL, OS_MESG_BLOCK);
    draw_buffer ^= 1;

    // theta += 1.0F;

    if (theta == 300 || theta == -300) {
      toggle ^= 1;
    }

    if (toggle) {
      theta += 1.0F;
    } else {
      theta -= 1.0F;
    }
  }
}
